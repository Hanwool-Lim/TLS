#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <resolv.h>

// openssl
#include <openssl/rsa.h>
#include <openssl/crypto.h>
#include <openssl/x509.h>
#include <openssl/pem.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

//homedir for key and cert file
#define HOME "./"

//key and cert file
#define CERTF HOME "server.crt"
#define KEYF HOME "server.key"

int OpenListener(int port){ //소켓을 생성하는 함수
	int sd; //listen sd
	struct sockaddr_in addr; //server address 
	//sockaddr_in : IPv4에서 소켓구조를 표현하는 구조체

	sd = socket(PF_INET, SOCK_STREAM, 0); //소켓을 생성하는 함수
	//domain : PF_INET
	//type : SOCK_STREAM = tcp
	//protocol : type에서 미리 지정한 경우 0을 입력
	//소켓을 만들어만놓은것이지 안에 데이터를 삽입하거나 한 것은 아님
	
	bzero(&addr, sizeof(addr));
	//메모리 공간을 size만큼 0으로 채우는 함수(ptr 주소값부터 size바이트만큼 0으로 채움)
	
	addr.sin_family = AF_INET; //주소체계(AF_INET)
	addr.sin_port = htons(port); //포트번호
	addr.sin_addr.s_addr = INADDR_ANY; //IP주소
	//INADDR_ANY를 사용하면 IP주소를 자동으로 찾아서 대입

	if(bind(sd, (struct sockaddr *) &addr, sizeof(addr)) != 0){
		perror("can't bind port");
		abort(); //terminate program
	}
	//bind : 클라이언트에서 접속할수 있는 서버의 주소를 설정하는 함수
	// 		(생성한 소켓에 정보를 저장)
	// 소켓 : 프로세스가 네트워크를 통해 데이터를 주고받기위한 창구
	//		(IP주소, 포트번호, 프로토콜이 모여져서 만들어지는 것)
	// 포트 : 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기위한 고유한 값

	if(listen(sd, 10)!=0){
		perror("Can't configure listening port");
		abort();
	}
	//listen : 지정한 소켓 디스크립터로 클라이언트의 접속요청을 기다리는 함수
	//		(보통 bind()함수와 같이 사용)
	
	return sd; //생성하고 데이터를 집어넣은 소켓을 반환
}

int isRoot(){
	if(getuid()!=0)
		return 0;
	else
		return 1;
}
//현재 프로그램을 사용한 주체를 확인하는 것
//getuid == 0 -> root sudo
//root, sudo로 프로그램을 시작할 경우 0을 반환
//아닐경우 1을 반환

SSL_CTX* InitServerCTX(void){ //암호화 통신을 위한 초기화 작업을 하는 함수 //SSL_CTX형식의 함수를 사용
	SSL_METHOD *method;
	SSL_CTX *ctx;

	OpenSSL_add_all_algorithms(); //모든 암호화 타입들을 로드
	SSL_load_error_strings(); //에러메세지 문자열을 로드

	method = TLSv1_2_server_method(); 
	//TLS에 대한 메소드를 생성
	//TLS v1.2의 서버 메소드를 생성
	
	ctx = SSL_CTX_new(method);
	//위에서 생성한 메소드를 활용하여 새로운 SSL_CTX를 생성
	//SSL_CTX : SSL/TLS를 구축하기위한 프레임워크(SSL Context를 생성)

	if(ctx == NULL){
		ERR_print_errors_fp(stderr);
		abort();
	}
	return ctx;
	//마지막으로 ctx를 반환
	// SSL/TLS를 구축하기위한 프레임워크 
}

void LoadCertificates(SSL_CTX* ctx, char* CertFile, char* KeyFile){
	if(SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM)<=0){
		ERR_print_errors_fp(stderr);
		abort();
	}

	if(SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <=0){
		ERR_print_errors_fp(stderr);
		abort();
	}
	
	if(!SSL_CTX_check_private_key(ctx)){
		fprintf(stderr, "Private key does not match the public certificate\n");
		abort();
	}
}

int main(int count, char *argc[]){
	SSL_CTX *ctx;
	int server;
	char *portnum;

	if(!isRoot()){
		printf("This program must be run as root/sudo user!!\n");
		exit(0);
	}
	
	if(count!=2){
		printf("Usage : %s <portnum>\n", Argc[0]);
		exit(0);
	}

	SSL_library_init();
}


